/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under both the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree and the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree.
 */

//! This module is responsible for loading for each project list of relevant
//! paths that those project cover.

mod eden_prefetch;
mod files_uniqueness_check;
mod project_files_load;
mod projectless_files;

use anyhow::Result;
use slog::Logger;

use self::files_uniqueness_check::files_uniqueness_check;
pub use self::r#impl::ProjectFiles;
pub use self::r#impl::ProjectlessFiles;
use crate::config::SelectedProjects;
use crate::paths::FbcodeRoot;
use crate::paths::FbsourceRoot;
use crate::paths::PathInFbcode;

/// Main structure of this module which performs the loading of relevant paths.
pub struct ProjectLoader<'proj, 'a> {
    /// Used for logging.
    pub logger: &'a Logger,
    /// Root of fbsource.
    pub fbsource_root: &'a FbsourceRoot,
    /// Root of fbcode.
    pub fbcode_root: &'a FbcodeRoot,
    /// Configs of projects selected by user.
    pub configs: &'a SelectedProjects<'proj>,
    /// Input paths provided by user.
    pub input_paths: Vec<PathInFbcode>,
}

impl<'proj, 'a> ProjectLoader<'proj, 'a> {
    /// Load files for selected projects. It does so by:
    /// - prefetching files using eden to speed up operations on EdenFS
    /// - using include/exclude globs from projects gather the relevant paths
    /// - check those paths and validate them for uniqueness, so two projects
    ///   don't try to cover the same paths
    /// - compute which files provided by user were not covered by any project
    pub async fn load(self) -> Result<(Vec<ProjectFiles<'proj>>, ProjectlessFiles)> {
        // Prefetching files with eden should speed up further operations
        self.eden_prefetch().await?;
        let project_files_list = self.project_files_load().await?;
        let (all_cargo, all_targets, all_additional) = files_uniqueness_check(&project_files_list)?;
        let projectless_files = self.projectless_files(all_cargo, all_targets, all_additional);
        Ok((project_files_list, projectless_files))
    }
}

/// Putting the following structs in a separate module will force other
/// submodules to use their constructors rather than the struct construct.
mod r#impl {
    use getset::Getters;

    use crate::config::ProjectConf;
    use crate::paths::CargoTomlPath;
    use crate::paths::PathInFbcode;
    use crate::paths::TargetsPath;

    /// Structure that holds files covered by a single project.
    #[derive(Debug, Getters)]
    #[getset(get = "pub")]
    pub struct ProjectFiles<'proj> {
        /// Reference to the project config.
        conf: &'proj ProjectConf,
        /// Cargo.toml paths covered by project config.
        cargo: Vec<CargoTomlPath>,
        /// TARGETS paths covered by project config.
        targets: Vec<TargetsPath>,
        /// Some additional files that are generated by autocargo.
        additional: Vec<PathInFbcode>,
    }

    impl<'proj> ProjectFiles<'proj> {
        /// Sorts cargo and targets vectors before storing them in struct.
        pub fn new(
            conf: &'proj ProjectConf,
            mut cargo: Vec<CargoTomlPath>,
            mut targets: Vec<TargetsPath>,
            mut additional: Vec<PathInFbcode>,
        ) -> Self {
            cargo.sort_unstable();
            targets.sort_unstable();
            additional.sort_unstable();

            Self {
                conf,
                cargo,
                targets,
                additional,
            }
        }

        #[cfg(test)]
        pub fn targets_mut(&mut self) -> &mut Vec<TargetsPath> {
            &mut self.targets
        }
    }

    /// Structure that holds files not covered by any project.
    #[derive(Eq, PartialEq, Debug, Getters)]
    #[getset(get = "pub")]
    pub struct ProjectlessFiles {
        /// Cargo.toml files not covered by any project.
        cargo: Vec<CargoTomlPath>,
        /// TARGETS files not covered by any project.
        targets: Vec<TargetsPath>,
        /// Some additional files that are generated by autocargo.
        additional: Vec<PathInFbcode>,
    }

    impl ProjectlessFiles {
        /// Sorts cargo and targets vectors before storing them in struct.
        pub fn new(
            mut cargo: Vec<CargoTomlPath>,
            mut targets: Vec<TargetsPath>,
            mut additional: Vec<PathInFbcode>,
        ) -> Self {
            cargo.sort_unstable();
            targets.sort_unstable();
            additional.sort_unstable();

            Self {
                cargo,
                targets,
                additional,
            }
        }
    }
}
