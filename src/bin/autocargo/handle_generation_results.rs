/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under both the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree and the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree.
 */

use std::collections::HashMap;
use std::collections::HashSet;
use std::convert::identity;
use std::hash::Hash;
use std::path::Path;

use anyhow::Context;
use anyhow::Result;
use autocargo::cargo_generator::GENERATED_PREAMBLE;
use autocargo::cargo_generator::GenerationOutput;
use autocargo::config::ProjectConf;
use autocargo::paths::CargoTomlPath;
use autocargo::paths::FbcodeRoot;
use autocargo::paths::PathInFbcode;
use autocargo::project_loader::ProjectFiles;
use autocargo::project_loader::ProjectlessFiles;
use futures::FutureExt;
use futures::TryStreamExt;
use futures::future::BoxFuture;
use futures::stream::FuturesUnordered;
use slog::Logger;
use slog::info;
use slog::warn;
use tokio::fs::create_dir_all;
use tokio::fs::read;
use tokio::fs::read_to_string;
use tokio::fs::remove_file;
use tokio::fs::write;

pub async fn handle_generation_results<'a>(
    logger: &Logger,
    fbcode_root: &'a FbcodeRoot,
    generated: &'a GenerationOutput,
    project_files: &'a [ProjectFiles<'a>],
    projectless_files: &'a ProjectlessFiles,
) -> Result<()> {
    let files_to_delete: HashSet<_> =
        get_files_to_delete(fbcode_root, generated, project_files, projectless_files).await?;

    if !files_to_delete.is_empty() {
        warn!(
            logger,
            "Deleting {} files that are no longer generated by any project.",
            files_to_delete.len()
        );
    }

    let manifests_count = generated.cargo_manifests.len();
    let additional_files = generated.additional_files.len();

    let files_to_save = generated
        .cargo_manifests
        .iter()
        .map(|(path, content)| (path.as_file(), content.to_toml_string()))
        .chain(
            generated
                .additional_files
                .iter()
                .map(|(path, content)| (path, content.clone())),
        );

    persist_generation(
        logger,
        fbcode_root,
        manifests_count,
        additional_files,
        files_to_save,
        files_to_delete,
    )
    .await
}

async fn persist_generation<'a>(
    logger: &Logger,
    fbcode_root: &'a FbcodeRoot,
    manifests_count: usize,
    additional_files: usize,
    files_to_save: impl IntoIterator<Item = (&'a PathInFbcode, String)>,
    files_to_delete: impl IntoIterator<Item = &'a PathInFbcode>,
) -> Result<()> {
    files_to_delete
        .into_iter()
        .map(|path| {
            let path = Path::join(fbcode_root.as_ref(), path.as_ref());
            async move { remove_file(path).await }
        })
        .collect::<FuturesUnordered<_>>()
        .try_collect::<()>()
        .await?;

    files_to_save
        .into_iter()
        .map(|(path, content)| {
            let path = Path::join(fbcode_root.as_ref(), path.as_ref());
            async move {
                // Avoid triggering file watchers for files without changes.
                if read(&path).await.is_ok_and(|x| x == content.as_bytes()) {
                    Ok(())
                } else {
                    if let Some(dir) = path.parent() {
                        create_dir_all(dir).await?;
                    }
                    write(path, content.as_bytes()).await
                }
            }
        })
        .collect::<FuturesUnordered<_>>()
        .try_collect::<Vec<()>>()
        .await?;

    if manifests_count > 0 || additional_files > 0 {
        info!(
            logger,
            "Successfully generated {}{}{} files and stored them on disk",
            if manifests_count > 0 {
                format!("{} Cargo.toml", manifests_count)
            } else {
                "".to_owned()
            },
            if manifests_count > 0 && additional_files > 0 {
                " and "
            } else {
                ""
            },
            if additional_files > 0 {
                format!("{} additional", additional_files)
            } else {
                "".to_owned()
            }
        )
    }

    Ok(())
}

async fn get_files_to_delete<'a>(
    fbcode_root: &'a FbcodeRoot,
    generated: &'a GenerationOutput,
    project_files: &'a [ProjectFiles<'a>],
    projectless_files: &'a ProjectlessFiles,
) -> Result<HashSet<&'a PathInFbcode>> {
    let GenerationOutput {
        cargo_manifests,
        additional_files,
    } = generated;

    project_files
        .iter()
        .flat_map(|project_files| {
            get_files_to_delete_helper(
                fbcode_root,
                cargo_manifests,
                Some(*project_files.conf()),
                project_files.cargo(),
                CargoTomlPath::as_file,
            )
            .chain(get_files_to_delete_helper(
                fbcode_root,
                additional_files,
                Some(*project_files.conf()),
                project_files.additional(),
                identity,
            ))
        })
        .chain(get_files_to_delete_helper(
            fbcode_root,
            cargo_manifests,
            None,
            projectless_files.cargo(),
            CargoTomlPath::as_file,
        ))
        .chain(get_files_to_delete_helper(
            fbcode_root,
            additional_files,
            None,
            projectless_files.additional(),
            identity,
        ))
        .collect::<FuturesUnordered<_>>()
        .try_filter_map(|p| async move { Ok(p) })
        .try_collect()
        .await
}

fn get_files_to_delete_helper<'a, P, T>(
    fbcode_root: &'a FbcodeRoot,
    generated: &'a HashMap<P, T>,
    project_conf: Option<&'a ProjectConf>,
    paths: impl IntoIterator<Item = &'a P> + 'a,
    to_path_in_fbcode: impl Fn(&'a P) -> &'a PathInFbcode + 'a,
) -> impl Iterator<Item = BoxFuture<'a, Result<Option<&'a PathInFbcode>>>> + 'a
where
    P: Eq + Hash + Sync,
    T: Sync,
{
    paths.into_iter().map(move |path| {
        let path_in_fbcode = to_path_in_fbcode(path);
        async move {
            Ok(if generated.contains_key(path) {
                // This file was regenerated, so we won't have to check if it
                // should be deleted.
                None
            } else {
                let is_inside_public_dir = project_conf
                    .and_then(|conf| conf.oss_git_config().as_ref())
                    .and_then(|oss| oss.public_cargo_dir.as_ref())
                    .is_some_and(|public_cargo_dir| {
                        path_in_fbcode
                            .as_ref()
                            .starts_with(public_cargo_dir.as_ref())
                    });
                if is_inside_public_dir {
                    // We relentlessly remove all files from public dir if they
                    // were not regenerated.
                    Some(path_in_fbcode)
                } else {
                    let is_content_autocargo_generated =
                        read_to_string(Path::join(fbcode_root.as_ref(), path_in_fbcode.as_ref()))
                            .await
                            .with_context(|| {
                                format!(
                                    "While processing files to delete for {}",
                                    project_conf.map_or_else(
                                        || "projectless files".to_owned(),
                                        |conf| format!("project {}", conf.name())
                                    )
                                )
                            })?
                            .lines()
                            .next()
                            .is_some_and(|line| line.contains(GENERATED_PREAMBLE));
                    if is_content_autocargo_generated {
                        Some(path_in_fbcode)
                    } else {
                        None
                    }
                }
            })
        }
        .boxed()
    })
}
